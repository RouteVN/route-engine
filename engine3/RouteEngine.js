import applyPresentationInstructions from "./applyPresentationInstructions";
import applySystemInstructions from "./applySystemInstructions";
import combineSystemState from "./combineSystemState";
import * as systemStateSelectors from "./systemStateSelectors";
import * as vnDataSelectors from "./vnDataSelectors";

class RouteEngine {
  _effects = [];
  _vnData;
  _systemState;
  _ticker;
  _render;

  constructor() {}

  /**
   * Initialize the engine with visual novel data and rendering functions
   */
  init = ({ vnData, render, ticker }) => {
    this._vnData = vnData;
    this._ticker = ticker;
    this._render = render;
    this._currentTimerEffect;

    // Set up initial state
    const initialIds = vnDataSelectors.selectInitialIds(vnData);
    const { sectionId, stepId } = initialIds;
    if (!sectionId || !stepId) {
      throw new Error("No initial sectionId found");
    }

    const saveDataString = localStorage.getItem('saveData');
    const saveData = saveDataString ? JSON.parse(saveDataString) : [];
    
    this._systemState = systemStateSelectors.createSystemState({
      sectionId,
      stepId,
      presetId: initialIds.presetId,
      autoNext: initialIds.autoNext,
      saveData,
    });

    // Register effect handlers
    this.registerEffects({
      name: "render",
      effect: this.render,
    });

    this.registerEffects({
      name: 'systemInstructions',
      effect: this.systemInstructionsHandler,
    });

    this.registerEffects({
      name: 'cancelTimerEffect',
      effect: this.cancelTimerEffect,
    })

    this.registerEffects({
      name: 'saveVnData',
      effect: this.saveVnData,
    })

    this.render();
  };

  saveVnData = (_, options) => {
    const { saveData } = options;
    localStorage.setItem('saveData', JSON.stringify(saveData));
  }

  /**
   * Handles delayed execution of system instructions
   */
  handleDelayedExecution = (options, callback) => {
    const { delay } = options;
    if (!delay) {
      callback();
      return;
    }
    
    let elapsedInMs = 0;
    const timerEffect = (time) => {
      elapsedInMs += time.deltaMS;
      if (elapsedInMs >= delay) {
        this._ticker.remove(timerEffect);
        callback();
      }
    };
    
    this._ticker.add(timerEffect);
    this._currentTimerEffect = timerEffect;
  };

  cancelTimerEffect = () => {
    if (this._currentTimerEffect) {
      this._ticker.remove(this._currentTimerEffect);
      this._currentTimerEffect = undefined;
    }
  };

  /**
   * Handles system instructions with potential delays
   */
  systemInstructionsHandler = (_, options = {}) => {
    this.handleDelayedExecution(options, () => {
      this.applySystemInstructions(options.systemInstructions || {});
    });
  };

  /**
   * Apply system instructions and handle resulting effects
   */
  applySystemInstructions = (instructions) => {
    const { systemState, effects } = applySystemInstructions({
      systemInstructions: instructions,
      systemState: this._systemState,
      vnData: this._vnData,
    });

    this._systemState = systemState;
    
    // Handle all resulting effects
    this.processEffects(effects);
  };

  /**
   * Process the effects generated by system instructions
   */
  processEffects = (effects) => {
    if (!effects || !effects.length) {
      return;
    }
    
    for (const effect of effects) {
      const { name, options } = effect;
      const effectHandler = this._effects[name];
      
      if (effectHandler) {
        effectHandler(name, options);
      } else {
        console.warn(`Effect handler "${name}" not found`);
      }
    }
  };

  /**
   * Handles user input events by mapping them to system instructions
   */
  systemEventHandler = (event, payload = {}) => {
    // Handle step completion event
    if (event === 'completed') {
      this.applySystemInstructions({ stepCompleted: {} });
      return;
    }
    
    // Direct system instruction execution
    if (event === "systemInstructions") {
      this.systemInstructionsHandler(event, payload);
      return;
    }

    // Map events to system instructions using the current preset
    const presetId = systemStateSelectors.selectCurrentPresetId(this._systemState);
    const preset = vnDataSelectors.selectPreset(this._vnData, presetId);
    
    if (!preset) {
      console.warn(`No preset found with ID: ${presetId}`);
      return;
    }
    
    const eventMapping = preset.eventsMap[event];
    if (!eventMapping) {
      console.warn(`No mapping found for event: ${event} in preset: ${presetId}`);
      return;
    }
    
    this.applySystemInstructions(eventMapping.systemInstructions);
  };

  /**
   * Renders the current state of the visual novel
   */
  render = () => {
    const currentPointer = systemStateSelectors.selectCurrentPointer(this._systemState);
    const currentSteps = vnDataSelectors.selectSectionSteps(
      this._vnData,
      currentPointer.sectionId,
      currentPointer.stepId
    );

    if (!currentSteps.length) {
      console.warn(`No steps found for section: ${currentPointer.sectionId}, step: ${currentPointer.stepId}`);
      return;
    }

    const lastStep = currentSteps[currentSteps.length - 1];

    // Apply system instructions from the last step if present
    if (lastStep.systemInstructions) {
      if (this._systemState.story.lastStepAction === 'nextStep') {
        console.log('running apply system instructions from last step')
        this.applySystemInstructions(lastStep.systemInstructions);
      } else {
        console.log('skipping because history mode')
        if (!lastStep.presentation) {
          this.applySystemInstructions({
            prevStep: {}
          });
        }
      }
      return;
    }

    // Create presentation state
    const presentationInstructions = currentSteps.map((step) => step.presentation || {});
    const presentationTemplate = applyPresentationInstructions(presentationInstructions);
    const presentationState = combineSystemState({
      template: presentationTemplate,
      state: this._systemState,
      data: this._vnData,
    });

    // Render the presentation state
    this._render(presentationState);
  };

  /**
   * Register effect handlers
   */
  registerEffects = (options) => {
    this._effects[options.name] = options.effect;
  };
}

export default RouteEngine;
